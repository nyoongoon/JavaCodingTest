# 알고리즘 이론

## 정렬

### 기수 정렬 (Radix Sort)
- 낮은 자리 수부터 정렬하는 방식
- 각 원소간의 비교연산을 하지 않는 대신 기수 테이블을 위한 메모리 필요 (기수테이블은 Queue)
- 알고리즘 복잡도 : O(dn) -> d는 최대자릿수

### 계수 정렬 (Counting Sort)
- 숫자끼리 비교하지 않고 카운트를 세서 정렬하는 방식
- 카운팅을 위한 메모리 필요
- 알고리즘 복잡도 : O(n + k) -> k는 정렬 대상 데이터 중 최대 값

### 셸 정렬 (Shell Sort)
- 삽입 정렬의 약점을 보완한 정렬 방식
- 삽입 정렬의 약점 -> 오름차순 정렬 기준, 내림차순으로 구성된 데이터에 대해서는 앞의 데이터와 하나씩 비교하며 모두 교환 필요
- 이전의 모든 데이터와 비교하지 않고 일정 간격을 두어 비교
- 알고리즘 복잡도 : O(n^2) -> 간격 설정에 따라 worst case는 삽입정렬과 동일, 일반적인 산포 데이터 기준으로 삽입정렬보다 빠르다
![](img/img_8.png)


# 투포인터
- 배열에서 두개의 포인터를 사용하여 원하는 결과를 얻는 방법
- 두 개의 포인터의 배치 방법
- 1. 같은 방향에서 시작 : 첫 번째 원소에 둘 다 배치
- 2. 서로 다른 방향에서 시작 : 첫 번째 원소와 마지막 원소에 배치
- -> 다중 for문의 복잡도를 좀 더 선형적으로 풀 수 있다

# 그리디 
- 매순간 현재의 기준으로 최선의 답을 선택해 나가는 기법
- 빠르게 근사치를 계산할 수 있다
- 결과적으로 최적해가 아닐 수 있다 
## 그리디 예시
- 1. Activity Selection Problem
- N개의 활동과 각 활동의 시작/종료 시간이 주어졌을 때, 한 사람이 최대한 많이 할 수 있는 활동의 수 구하기
- -> 종료시간 기준으로 정렬하여 먼저 종료되는 활동 순, 겹치지 않는 순으로 선택한다. 
- 2. 거스름돈 문제
- 잔돈 890, 동전 종류 10, 50, 100, 500 일 때 동전의 수를 가장 적게 고르기
- -> 큰 동전부터 계산
## 그리디 적용 조건
- 그리디 알고리즘은 빠르지만 최적해를 보장하지 못함
- 하기 두가지 조건에 해당하는 경우 적용 가능
- 1. 탐욕적 특성 : 지금 선택이 다음 선택에 영향을 주지 않음 -> Activity Selection Problem (종료시간 끼리는 선택에 영향이 없다)
- 2. 최적 부분 구조 : 전체 문제의 최적해는 부분 문제의 최적해로 이루어짐  --> 거스름돈 문제

# 분할 정복
- 큰 문제를 작은 부분 문제로 나누어 해결하는 방법
- 합병 정렬, 퀵 정렬, 이진 탐색... 
- 분할 정복 과정 
- -> 문제를 하나 이상의 작은 부분들로 분할
- -> 부분들을 각각 정복
- -> 부분들의 해답을 통합하여 원래 문제의 답을 구함
## 분할 정복 장단점
- 장점
- -> 문제를 나누어 처리하기 어려운 문제를 해결
- -> 병렬 처리에 이점이 있음
- 단점
- -> 메모리를 많이 사용 (재귀 호출 구조)
